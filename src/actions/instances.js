// External dependencies
import queryString from 'query-string';

// Internal dependencies
import {INSTANCE_DELETION_SUCCESS, INSTANCE_DELETION_FAILURE, INSTANCE_CREATING, INSTANCE_SUCCESS, INSTANCE_FAILURE} from './action-types';
import {alertFailure, alertSuccess} from './alert';
import {handleResponse} from '../utils/ce-util';

const instanceCreating = activeElement => ({type: INSTANCE_CREATING, activeElement});
const instanceSuccess = data => ({type: INSTANCE_SUCCESS, data});
export const instanceFailure = error => ({type: INSTANCE_FAILURE, error});
const instanceDeletionSuccess = elementKey => ({type: INSTANCE_DELETION_SUCCESS, elementKey});
const instanceDeletionFailure = error => ({type: INSTANCE_DELETION_FAILURE, error});

const handleOAuthLoginEvent = (event, res, rej, handler) => {
  if (window.location.href.indexOf(event.origin) === 0) {
      rej({message: 'Failed to retrieve OAuth2 information'});
      window.removeEventListener('message', handler);
      return;
  }

  // Optional: ignore if it didn't come from an approved origin or if the URL is not on the message yet
  // const approvedOauthResponders = ['https://ezra-ui.com'];
  // if (!approvedOauthResponders.includes(event.origin) || isNil(event.data)) {
  //     return;
  // }

  const eventData = event.data;
  if (!eventData || !eventData.success) rej({message: `Failed to retrieve instance data from: ${JSON.stringify(event.data)}, ${JSON.stringify(eventData.error)}`});

  res({data: eventData.data});
};

const handleOAuthLogin = (oauthWindow, oauthUrl) => {
  let intervalId, messageHandler;
  return new Promise((res, rej) => {
      // this shouldn't happen with the way we're passing down the oauthWindow from the original onClick event
      // as that works around when someone has popups blocked.  but just in case we'll check here...
      if (!oauthWindow) {
          rej({message: 'Please enable popups in your browser to create OAuth element instances'});
          return;
      }
      console.log('Redirecting to', oauthUrl);
  
      // send the window to the oauth url
      oauthWindow.location.href = oauthUrl;
  
      intervalId = window.setInterval(() => {
      try {
          oauthWindow.postMessage({ready: true}, '*');
      } catch(e) {
          // Do nada
      }}, 500);
  
      messageHandler = evt => handleOAuthLoginEvent(evt, res, rej, messageHandler);
  
      window.addEventListener('message', messageHandler);
  }).finally(() => {
      clearInterval(intervalId);
      window.removeEventListener('message', messageHandler);
  });
};

const createSession = (ceKeys, data) => {
  return () => {
    const applicationId = process.env.REACT_APP_EZRA_APP_ID;
    const baseEzraUrl = process.env.REACT_APP_EZRA_APP_URI;
    const ezraUiUri = process.env.REACT_APP_EZRA_UI_URI;
      // The query parameters with the api key, api secret, and callback url.
    const queryParams = queryString.stringify({
      apiKey: data.vendorApiKey,
      apiSecret: data.vendorSecret,
      elementKey: data.elementKey,
      callbackUrl: `${ezraUiUri}/callback`,
    });
    // the normalized Cloud Elements URL for retrieving an OAuth redirect
    const path = `${applicationId}/sessions`;
    // place everything above into an object for fetch to use
    const config = {
      method: 'POST',
      headers: {
          'Authorization': `User ${ceKeys.userToken}, Organization ${ceKeys.orgToken}`,
          'Content-Type': 'application/json',
          'Accept': 'application/json'
      }
    };

    return fetch(`${baseEzraUrl}/${path}?${queryParams}`, config);
  };
};

// TODO change name
export const getEzraRedirectUrl = (ceKeys, vendorData) => {
  const elementKey = vendorData.elementKey;
  return (dispatch) => {
    dispatch(instanceCreating({key: elementKey, name: vendorData.nameText}));
    return dispatch(createSession(ceKeys, vendorData))
      .then(handleResponse)
      .then(r => r.json())
      .then(r => {
        const redirectUrl = r.redirectUrl;
        // Redirect user to url generated by Cloud Elements
        const oauthWindow = window.open('', '_blank');
        return handleOAuthLogin(oauthWindow, redirectUrl);
      })
      .then(r => {
        console.log('Connection creation success', r);
        dispatch(instanceSuccess({ [elementKey] : r.data.elementInstance }));
        dispatch(alertSuccess("Connection created successfully"));
    })
      .catch(e => {
        console.error('Connection creation failed', e);
        dispatch(instanceFailure(e));
        dispatch(alertFailure("Connection creation failed"));
    });
  };
};

const deleteInstance = (ceKeys, instance) => {
  return () => {
    const baseUrl = process.env.REACT_APP_CE_ENV_URI;
    // place everything above into an object for fetch to use
    const config = {
        method: 'DELETE',
        headers: {
            'Authorization': `User ${ceKeys.userToken}, Organization ${ceKeys.orgToken}`,
            'Accept': 'application/json'
        }
    };
    return fetch(`${baseUrl}/elements/api-v2/instances/${instance.id}`, config);
  };
};

export const removeInstance = (ceKeys, instance) => {
  const elementKey = instance.element.key;
  return (dispatch) => {
    return dispatch(deleteInstance(ceKeys, instance))
      .then(handleResponse)
      .then(r => {
        console.log('Connection removal success', r);
        dispatch(instanceDeletionSuccess(elementKey));
        dispatch(alertSuccess("Connection deleted successfully"));
    })
      .catch(e => {
        console.error('Connection removal failed', e);
        dispatch(instanceDeletionFailure(e));
        dispatch(alertFailure("Connection deleted failed"));
    });
  };
};
